# Booking a Boyfriend - Enterprise Platform

## Executive Summary

**Project**: Enterprise-grade male companion booking platform with real-time communication, secure payments, and comprehensive business analytics.

**Architecture**: Next.js 15, Supabase, PostgreSQL, Stripe, Redis, Cloudinary, Sentry, Plausible.

**Scale**: Designed for 1M+ users with enterprise-grade security, performance, and reliability.

---

## Project Architecture

### Directory Structure

```
/app
├── (authenticated)/           # Protected routes
│   ├── dashboard/            # User dashboard
│   ├── bookings/             # Booking management
│   ├── messages/             # Real-time messaging
│   ├── profile/              # Profile management
│   └── settings/             # User preferences
├── (public)/                 # Public routes
│   ├── browse/              # Boyfriend discovery
│   ├── boyfriend/[id]/       # Boyfriend profiles
│   └── pricing/             # Subscription plans
├── admin/                    # Admin dashboard
├── api/                      # API routes
│   ├── auth/                # Authentication endpoints
│   ├── bookings/            # Booking operations
│   ├── boyfriends/          # Boyfriend management
│   ├── payments/            # Payment processing
│   └── analytics/           # Analytics data
└── globals.css              # Global styles

/components
├── ui/                       # Reusable UI components
│   ├── button.tsx           # Button variants
│   ├── input.tsx            # Form inputs
│   ├── modal.tsx            # Modal dialogs
│   ├── card.tsx             # Content cards
│   └── avatar.tsx           # User avatars
├── forms/                   # Complex forms
│   ├── booking-form.tsx     # Booking creation
│   ├── profile-form.tsx     # Profile editing
│   ├── payment-form.tsx     # Payment processing
│   └── search-filters.tsx   # Advanced filtering
├── layouts/                 # Layout components
│   ├── header.tsx           # Site navigation
│   ├── footer.tsx           # Site footer
│   ├── sidebar.tsx          # Dashboard sidebar
│   └── mobile-nav.tsx       # Mobile navigation
└── features/                # Feature-specific components
    ├── chat/               # Messaging components
    ├── booking/            # Booking components
    ├── profile/            # Profile components
    └── admin/              # Admin components

/lib
├── database/                # Database utilities
│   ├── client.ts           # Supabase client
│   ├── schema.ts           # Database types
│   └── queries.ts          # Database queries
├── services/               # Business logic services
│   ├── auth.service.ts     # Authentication
│   ├── booking.service.ts  # Booking operations
│   ├── payment.service.ts  # Payment processing
│   ├── messaging.service.ts # Real-time messaging
│   └── analytics.service.ts # Analytics tracking
├── hooks/                  # Custom React hooks
│   ├── use-auth.ts         # Authentication state
│   ├── use-bookings.ts     # Booking management
│   ├── use-realtime.ts     # Real-time subscriptions
│   └── use-analytics.ts    # Analytics tracking
├── utils/                  # Utility functions
│   ├── format.ts           # Data formatting
│   ├── validation.ts       # Form validation
│   ├── constants.ts        # Application constants
│   └── helpers.ts          # Helper functions
└── config/                 # Configuration
    ├── environment.ts      # Environment variables
    ├── features.ts         # Feature flags
    └── settings.ts         # Application settings

/supabase
├── migrations/             # Database migrations
│   ├── 001_initial_schema.sql
│   ├── 002_rls_policies.sql
│   ├── 003_indexes.sql
│   └── 004_functions.sql
├── functions/              # Edge functions
│   ├── stripe-webhook/     # Payment webhooks
│   └── image-processing/   # Image optimization
└── config.toml            # Supabase configuration

/messages                   # Internationalization
├── en.json                 # English translations
├── es.json                 # Spanish translations
├── fr.json                 # French translations
├── de.json                 # German translations
├── it.json                 # Italian translations
├── pt.json                 # Portuguese translations
├── ja.json                 # Japanese translations
├── ko.json                 # Korean translations
└── zh.json                 # Chinese translations

/public                     # Static assets
├── images/                 # Image assets
├── icons/                  # Icon assets
├── manifest.json           # PWA manifest
└── sw.js                   # Service worker

/tests                     # Test suites
├── unit/                  # Unit tests
├── integration/           # Integration tests
└── e2e/                   # End-to-end tests
```

---

## Database Schema

### Core Tables

#### Users Table (extends auth.users)
```sql
-- Enhanced user profiles
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  display_name TEXT,
  avatar_url TEXT,
  bio TEXT,
  location JSONB, -- {city, country, coordinates}
  timezone TEXT DEFAULT 'UTC',
  language TEXT DEFAULT 'en',
  user_type TEXT CHECK (user_type IN ('client', 'boyfriend')) NOT NULL,
  verification_status TEXT DEFAULT 'unverified' CHECK (verification_status IN ('unverified', 'pending', 'verified', 'rejected')),
  verification_documents JSONB DEFAULT '[]',
  rating DECIMAL(3,2),
  review_count INTEGER DEFAULT 0,
  total_earnings DECIMAL(10,2) DEFAULT 0,
  subscription_tier TEXT DEFAULT 'free' CHECK (subscription_tier IN ('free', 'premium', 'vip')),
  preferences JSONB DEFAULT '{}',
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_profiles_user_type ON public.profiles(user_type);
CREATE INDEX idx_profiles_location ON public.profiles USING GIST(ST_Point((location->>'longitude')::float, (location->>'latitude')::float));
CREATE INDEX idx_profiles_rating ON public.profiles(rating DESC);
CREATE INDEX idx_profiles_verification ON public.profiles(verification_status);
```

#### Boyfriends Table
```sql
-- Boyfriend-specific data
CREATE TABLE public.boyfriends (
  id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  hourly_rate DECIMAL(8,2) NOT NULL,
  availability_schedule JSONB DEFAULT '{}',
  services_offered TEXT[] DEFAULT '{}',
  specializations TEXT[] DEFAULT '{}',
  languages_spoken TEXT[] DEFAULT '{en}',
  height INTEGER,
  weight INTEGER,
  body_type TEXT,
  hair_color TEXT,
  eye_color TEXT,
  ethnicity TEXT,
  age INTEGER,
  portfolio_images TEXT[] DEFAULT '{}',
  featured BOOLEAN DEFAULT FALSE,
  featured_until TIMESTAMPTZ,
  response_time_minutes INTEGER DEFAULT 60,
  acceptance_rate DECIMAL(5,2) DEFAULT 0,
  completed_bookings INTEGER DEFAULT 0,
  active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_boyfriends_hourly_rate ON public.boyfriends(hourly_rate);
CREATE INDEX idx_boyfriends_active ON public.boyfriends(active) WHERE active = true;
CREATE INDEX idx_boyfriends_featured ON public.boyfriends(featured) WHERE featured = true;
CREATE INDEX idx_boyfriends_services ON public.boyfriends USING GIN(services_offered);
```

#### Bookings Table
```sql
-- Booking system
CREATE TABLE public.bookings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID NOT NULL REFERENCES public.profiles(id),
  boyfriend_id UUID NOT NULL REFERENCES public.boyfriends(id),
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'in_progress', 'completed', 'cancelled', 'no_show')),
  service_type TEXT NOT NULL,
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,
  duration_hours DECIMAL(4,2) NOT NULL,
  location TEXT,
  meeting_point TEXT,
  special_requests TEXT,
  total_amount DECIMAL(10,2) NOT NULL,
  platform_fee DECIMAL(8,2) NOT NULL,
  boyfriend_earnings DECIMAL(8,2) NOT NULL,
  payment_status TEXT DEFAULT 'pending' CHECK (payment_status IN ('pending', 'paid', 'refunded', 'failed')),
  payment_intent_id TEXT,
  stripe_payment_id TEXT,
  cancellation_reason TEXT,
  cancelled_by UUID REFERENCES public.profiles(id),
  cancelled_at TIMESTAMPTZ,
  notes TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_bookings_client ON public.bookings(client_id);
CREATE INDEX idx_bookings_boyfriend ON public.bookings(boyfriend_id);
CREATE INDEX idx_bookings_status ON public.bookings(status);
CREATE INDEX idx_bookings_start_time ON public.bookings(start_time);
CREATE INDEX idx_bookings_payment_status ON public.bookings(payment_status);
```

#### Messages Table
```sql
-- Real-time messaging
CREATE TABLE public.messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL,
  sender_id UUID NOT NULL REFERENCES public.profiles(id),
  recipient_id UUID NOT NULL REFERENCES public.profiles(id),
  content TEXT NOT NULL,
  message_type TEXT DEFAULT 'text' CHECK (message_type IN ('text', 'image', 'system')),
  media_url TEXT,
  read_at TIMESTAMPTZ,
  delivered_at TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Conversation tracking
CREATE TABLE public.conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  participant_1 UUID NOT NULL REFERENCES public.profiles(id),
  participant_2 UUID NOT NULL REFERENCES public.profiles(id),
  last_message_at TIMESTAMPTZ DEFAULT NOW(),
  last_message_preview TEXT,
  unread_count_1 INTEGER DEFAULT 0,
  unread_count_2 INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(participant_1, participant_2)
);

-- Indexes
CREATE INDEX idx_messages_conversation ON public.messages(conversation_id);
CREATE INDEX idx_messages_sender ON public.messages(sender_id);
CREATE INDEX idx_messages_created_at ON public.messages(created_at DESC);
CREATE INDEX idx_conversations_participants ON public.conversations(participant_1, participant_2);
```

#### Reviews & Ratings
```sql
-- Review system
CREATE TABLE public.reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  booking_id UUID NOT NULL REFERENCES public.bookings(id),
  reviewer_id UUID NOT NULL REFERENCES public.profiles(id),
  reviewee_id UUID NOT NULL REFERENCES public.profiles(id),
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT,
  categories JSONB DEFAULT '{}', -- {communication, punctuality, service_quality, etc.}
  verified BOOLEAN DEFAULT FALSE,
  response TEXT,
  response_at TIMESTAMPTZ,
  helpful_votes INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_reviews_booking ON public.reviews(booking_id);
CREATE INDEX idx_reviews_reviewee ON public.reviews(reviewee_id);
CREATE INDEX idx_reviews_rating ON public.reviews(rating);
```

### Row Level Security (RLS) Policies

```sql
-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.boyfriends ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;

-- Profiles policies
CREATE POLICY "Users can view all profiles" ON public.profiles
FOR SELECT USING (true);

CREATE POLICY "Users can update own profile" ON public.profiles
FOR UPDATE USING (auth.uid() = id);

-- Boyfriends policies
CREATE POLICY "Anyone can view active boyfriends" ON public.boyfriends
FOR SELECT USING (active = true);

CREATE POLICY "Boyfriends can update own profile" ON public.boyfriends
FOR UPDATE USING (auth.uid() = id);

-- Bookings policies
CREATE POLICY "Users can view own bookings" ON public.bookings
FOR SELECT USING (auth.uid() = client_id OR auth.uid() = boyfriend_id);

CREATE POLICY "Clients can create bookings" ON public.bookings
FOR INSERT WITH CHECK (auth.uid() = client_id);

-- Messages policies
CREATE POLICY "Users can view messages in their conversations" ON public.messages
FOR SELECT USING (
  auth.uid() = sender_id OR auth.uid() = recipient_id
);

CREATE POLICY "Users can send messages" ON public.messages
FOR INSERT WITH CHECK (auth.uid() = sender_id);

-- Reviews policies
CREATE POLICY "Anyone can view reviews" ON public.reviews
FOR SELECT USING (true);

CREATE POLICY "Users can create reviews for their completed bookings" ON public.reviews
FOR INSERT WITH CHECK (
  auth.uid() = reviewer_id AND
  EXISTS (
    SELECT 1 FROM public.bookings
    WHERE id = booking_id AND client_id = auth.uid() AND status = 'completed'
  )
);
```

---

## Authentication & Authorization

### Authentication Service

```typescript
// lib/services/auth.service.ts
import { createClient } from '@supabase/supabase-js';
import { jwtDecode } from 'jwt-decode';

export class AuthService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  async signUp(email: string, password: string, userType: 'client' | 'boyfriend') {
    const { data, error } = await this.supabase.auth.signUp({
      email,
      password,
      options: {
        data: { user_type: userType }
      }
    });

    if (error) throw error;

    // Create profile record
    if (data.user) {
      await this.createProfile(data.user.id, email, userType);
    }

    return data;
  }

  async signIn(email: string, password: string) {
    const { data, error } = await this.supabase.auth.signInWithPassword({
      email,
      password
    });

    if (error) throw error;
    return data;
  }

  async signOut() {
    const { error } = await this.supabase.auth.signOut();
    if (error) throw error;
  }

  async resetPassword(email: string) {
    const { error } = await this.supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/reset-password`
    });

    if (error) throw error;
  }

  async updatePassword(password: string) {
    const { error } = await this.supabase.auth.updateUser({
      password
    });

    if (error) throw error;
  }

  private async createProfile(userId: string, email: string, userType: 'client' | 'boyfriend') {
    const { error } = await this.supabase
      .from('profiles')
      .insert({
        id: userId,
        email,
        user_type: userType
      });

    if (error) throw error;
  }

  getCurrentUser() {
    return this.supabase.auth.getUser();
  }

  getSession() {
    return this.supabase.auth.getSession();
  }

  onAuthStateChange(callback: (event: string, session: any) => void) {
    return this.supabase.auth.onAuthStateChange(callback);
  }
}
```

### Authentication Middleware

```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });

  const {
    data: { session },
  } = await supabase.auth.getSession();

  // Protected routes
  const protectedRoutes = ['/dashboard', '/bookings', '/messages', '/profile'];
  const isProtectedRoute = protectedRoutes.some(route =>
    req.nextUrl.pathname.startsWith(route)
  );

  // Admin routes
  const adminRoutes = ['/admin'];
  const isAdminRoute = adminRoutes.some(route =>
    req.nextUrl.pathname.startsWith(route)
  );

  if (isProtectedRoute && !session) {
    return NextResponse.redirect(new URL('/login', req.url));
  }

  if (isAdminRoute && session?.user?.user_metadata?.user_type !== 'admin') {
    return NextResponse.redirect(new URL('/dashboard', req.url));
  }

  return res;
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
};
```

---

## Payment Processing

### Stripe Integration

```typescript
// lib/services/payment.service.ts
import { createClient } from '@supabase/supabase-js';
import Stripe from 'stripe';

export class PaymentService {
  private stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
    apiVersion: '2023-10-16',
  });

  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  async createPaymentIntent(bookingId: string, amount: number, currency: string = 'usd') {
    // Get booking details
    const { data: booking } = await this.supabase
      .from('bookings')
      .select('*, client:profiles(*), boyfriend:boyfriends(*)')
      .eq('id', bookingId)
      .single();

    if (!booking) throw new Error('Booking not found');

    // Create payment intent
    const paymentIntent = await this.stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency,
      metadata: {
        booking_id: bookingId,
        client_id: booking.client_id,
        boyfriend_id: booking.boyfriend_id,
      },
    });

    // Update booking with payment intent
    await this.supabase
      .from('bookings')
      .update({
        payment_intent_id: paymentIntent.id,
        payment_status: 'pending'
      })
      .eq('id', bookingId);

    return paymentIntent;
  }

  async confirmPayment(paymentIntentId: string) {
    const paymentIntent = await this.stripe.paymentIntents.retrieve(paymentIntentId);

    if (paymentIntent.status === 'succeeded') {
      // Update booking status
      await this.supabase
        .from('bookings')
        .update({
          payment_status: 'paid',
          status: 'confirmed'
        })
        .eq('payment_intent_id', paymentIntentId);

      // Update boyfriend earnings
      const { data: booking } = await this.supabase
        .from('bookings')
        .select('boyfriend_earnings, boyfriend_id')
        .eq('payment_intent_id', paymentIntentId)
        .single();

      if (booking) {
        await this.supabase
          .from('profiles')
          .update({
            total_earnings: this.supabase.raw('total_earnings + ?', [booking.boyfriend_earnings])
          })
          .eq('id', booking.boyfriend_id);
      }
    }

    return paymentIntent;
  }

  async processRefund(bookingId: string, amount: number, reason: string) {
    const { data: booking } = await this.supabase
      .from('bookings')
      .select('payment_intent_id, stripe_payment_id')
      .eq('id', bookingId)
      .single();

    if (!booking?.stripe_payment_id) throw new Error('Payment not found');

    const refund = await this.stripe.refunds.create({
      payment_intent: booking.payment_intent_id,
      amount: Math.round(amount * 100),
      reason: 'requested_by_customer',
      metadata: {
        booking_id: bookingId,
        reason
      }
    });

    // Update booking
    await this.supabase
      .from('bookings')
      .update({
        payment_status: 'refunded',
        status: 'cancelled',
        cancellation_reason: reason
      })
      .eq('id', bookingId);

    return refund;
  }
}
```

### Webhook Handler

```typescript
// app/api/webhooks/stripe/route.ts
import { headers } from 'next/headers';
import { NextResponse } from 'next/server';
import Stripe from 'stripe';
import { PaymentService } from '@/lib/services/payment.service';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);
const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!;

export async function POST(request: Request) {
  const body = await request.text();
  const sig = headers().get('stripe-signature')!;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(body, sig, endpointSecret);
  } catch (err: any) {
    return NextResponse.json({ error: `Webhook signature verification failed.` }, { status: 400 });
  }

  const paymentService = new PaymentService();

  try {
    switch (event.type) {
      case 'payment_intent.succeeded':
        const paymentIntent = event.data.object as Stripe.PaymentIntent;
        await paymentService.confirmPayment(paymentIntent.id);
        break;

      case 'payment_intent.payment_failed':
        // Handle failed payment
        break;

      default:
        console.log(`Unhandled event type ${event.type}`);
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Webhook error:', error);
    return NextResponse.json({ error: 'Webhook handler failed' }, { status: 500 });
  }
}
```

---

## Real-time Messaging

### Messaging Service

```typescript
// lib/services/messaging.service.ts
import { createClient } from '@supabase/supabase-js';

export class MessagingService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  async sendMessage(conversationId: string, content: string, messageType: string = 'text') {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    // Get conversation participants
    const { data: conversation } = await this.supabase
      .from('conversations')
      .select('participant_1, participant_2')
      .eq('id', conversationId)
      .single();

    if (!conversation) throw new Error('Conversation not found');

    const recipientId = conversation.participant_1 === user.id
      ? conversation.participant_2
      : conversation.participant_1;

    // Insert message
    const { data: message, error } = await this.supabase
      .from('messages')
      .insert({
        conversation_id: conversationId,
        sender_id: user.id,
        recipient_id: recipientId,
        content,
        message_type: messageType
      })
      .select()
      .single();

    if (error) throw error;

    // Update conversation
    await this.supabase
      .from('conversations')
      .update({
        last_message_at: new Date().toISOString(),
        last_message_preview: content.substring(0, 100),
        unread_count_1: conversation.participant_1 === recipientId
          ? this.supabase.raw('unread_count_1 + 1')
          : this.supabase.raw('unread_count_1'),
        unread_count_2: conversation.participant_2 === recipientId
          ? this.supabase.raw('unread_count_2 + 1')
          : this.supabase.raw('unread_count_2')
      })
      .eq('id', conversationId);

    return message;
  }

  async markAsRead(conversationId: string) {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    // Mark messages as read
    await this.supabase
      .from('messages')
      .update({ read_at: new Date().toISOString() })
      .eq('conversation_id', conversationId)
      .eq('recipient_id', user.id)
      .is('read_at', null);

    // Reset unread count
    const updateField = user.id === (await this.supabase
      .from('conversations')
      .select('participant_1')
      .eq('id', conversationId)
      .single()).data?.participant_1
      ? 'unread_count_1'
      : 'unread_count_2';

    await this.supabase
      .from('conversations')
      .update({ [updateField]: 0 })
      .eq('id', conversationId);
  }

  async getConversations() {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const { data, error } = await this.supabase
      .from('conversations')
      .select(`
        *,
        participant_1_profile:profiles!participant_1(id, display_name, avatar_url),
        participant_2_profile:profiles!participant_2(id, display_name, avatar_url)
      `)
      .or(`participant_1.eq.${user.id},participant_2.eq.${user.id}`)
      .order('last_message_at', { ascending: false });

    if (error) throw error;
    return data;
  }

  subscribeToMessages(conversationId: string, callback: (message: any) => void) {
    return this.supabase
      .channel(`messages:${conversationId}`)
      .on('postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `conversation_id=eq.${conversationId}`
        },
        callback
      )
      .subscribe();
  }
}
```

---

## Booking Management

### Booking Service

```typescript
// lib/services/booking.service.ts
import { createClient } from '@supabase/supabase-js';
import { PaymentService } from './payment.service';

export class BookingService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  private paymentService = new PaymentService();

  async createBooking(bookingData: {
    boyfriendId: string;
    startTime: Date;
    duration: number;
    serviceType: string;
    location?: string;
    specialRequests?: string;
  }) {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    // Get boyfriend details
    const { data: boyfriend } = await this.supabase
      .from('boyfriends')
      .select('hourly_rate')
      .eq('id', bookingData.boyfriendId)
      .single();

    if (!boyfriend) throw new Error('Boyfriend not found');

    const totalAmount = boyfriend.hourly_rate * bookingData.duration;
    const platformFee = totalAmount * 0.15; // 15% platform fee
    const boyfriendEarnings = totalAmount - platformFee;

    // Create booking
    const { data: booking, error } = await this.supabase
      .from('bookings')
      .insert({
        client_id: user.id,
        boyfriend_id: bookingData.boyfriendId,
        start_time: bookingData.startTime.toISOString(),
        end_time: new Date(bookingData.startTime.getTime() + bookingData.duration * 60 * 60 * 1000).toISOString(),
        duration_hours: bookingData.duration,
        service_type: bookingData.serviceType,
        location: bookingData.location,
        special_requests: bookingData.specialRequests,
        total_amount: totalAmount,
        platform_fee: platformFee,
        boyfriend_earnings: boyfriendEarnings
      })
      .select()
      .single();

    if (error) throw error;

    // Create payment intent
    const paymentIntent = await this.paymentService.createPaymentIntent(
      booking.id,
      totalAmount
    );

    return { booking, clientSecret: paymentIntent.client_secret };
  }

  async getUserBookings() {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const { data, error } = await this.supabase
      .from('bookings')
      .select(`
        *,
        client:profiles!client_id(display_name, avatar_url),
        boyfriend:boyfriends(id, profiles(display_name, avatar_url))
      `)
      .or(`client_id.eq.${user.id},boyfriend_id.eq.${user.id}`)
      .order('start_time', { ascending: false });

    if (error) throw error;
    return data;
  }

  async updateBookingStatus(bookingId: string, status: string, notes?: string) {
    const { error } = await this.supabase
      .from('bookings')
      .update({
        status,
        notes,
        updated_at: new Date().toISOString()
      })
      .eq('id', bookingId);

    if (error) throw error;
  }

  async cancelBooking(bookingId: string, reason: string) {
    const { data: { user } } = await this.supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const { error } = await this.supabase
      .from('bookings')
      .update({
        status: 'cancelled',
        cancellation_reason: reason,
        cancelled_by: user.id,
        cancelled_at: new Date().toISOString()
      })
      .eq('id', bookingId)
      .or(`client_id.eq.${user.id},boyfriend_id.eq.${user.id}`);

    if (error) throw error;
  }
}
```

---

## Analytics & Monitoring

### Analytics Service

```typescript
// lib/services/analytics.service.ts
import { createClient } from '@supabase/supabase-js';

export class AnalyticsService {
  private supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  async trackEvent(eventType: string, eventData: any, userId?: string) {
    const { error } = await this.supabase
      .from('user_behavior')
      .insert({
        user_id: userId,
        event_type: eventType,
        event_data: eventData,
        created_at: new Date().toISOString()
      });

    if (error) throw error;
  }

  async getDashboardMetrics(timeRange: string = '30d') {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - parseInt(timeRange));

    // User metrics
    const { data: userMetrics } = await this.supabase
      .from('user_behavior')
      .select('event_type, created_at')
      .gte('created_at', startDate.toISOString());

    // Booking metrics
    const { data: bookingMetrics } = await this.supabase
      .from('bookings')
      .select('status, total_amount, created_at')
      .gte('created_at', startDate.toISOString());

    // Revenue metrics
    const { data: revenueMetrics } = await this.supabase
      .from('bookings')
      .select('total_amount, platform_fee, status')
      .eq('payment_status', 'paid')
      .gte('created_at', startDate.toISOString());

    return {
      users: {
        total: new Set(userMetrics?.map(u => u.user_id)).size,
        active: userMetrics?.filter(u => u.event_type === 'login').length || 0
      },
      bookings: {
        total: bookingMetrics?.length || 0,
        completed: bookingMetrics?.filter(b => b.status === 'completed').length || 0,
        revenue: revenueMetrics?.reduce((sum, b) => sum + b.total_amount, 0) || 0,
        platformFees: revenueMetrics?.reduce((sum, b) => sum + b.platform_fee, 0) || 0
      }
    };
  }

  async getUserEngagement(userId: string) {
    const { data, error } = await this.supabase
      .from('user_behavior')
      .select('event_type, created_at')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .limit(100);

    if (error) throw error;

    return {
      lastActivity: data?.[0]?.created_at,
      totalEvents: data?.length || 0,
      eventTypes: data?.reduce((acc, event) => {
        acc[event.event_type] = (acc[event.event_type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>)
    };
  }
}
```

---

## Deployment & DevOps

### Environment Configuration

```typescript
// lib/config/environment.ts
export const config = {
  supabase: {
    url: process.env.NEXT_PUBLIC_SUPABASE_URL!,
    anonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY!
  },
  stripe: {
    publishableKey: process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!,
    secretKey: process.env.STRIPE_SECRET_KEY!,
    webhookSecret: process.env.STRIPE_WEBHOOK_SECRET!
  },
  redis: {
    url: process.env.REDIS_URL!
  },
  cloudinary: {
    cloudName: process.env.CLOUDINARY_CLOUD_NAME!,
    apiKey: process.env.CLOUDINARY_API_KEY!,
    apiSecret: process.env.CLOUDINARY_API_SECRET!
  },
  sentry: {
    dsn: process.env.SENTRY_DSN!
  },
  plausible: {
    domain: process.env.PLAUSIBLE_DOMAIN!
  }
};

export const isProduction = process.env.NODE_ENV === 'production';
export const isDevelopment = process.env.NODE_ENV === 'development';
```

### Docker Configuration

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci --only=production

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

ENV NEXT_TELEMETRY_DISABLED 1
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000

CMD ["node", "server.js"]
```

### CI/CD Pipeline

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run test
      - run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: akhileshns/heroku-deploy@v3.12.12
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: ${{ secrets.HEROKU_APP_NAME }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
```

---

## Security Considerations

### Data Protection
- All sensitive data encrypted at rest and in transit
- Row Level Security (RLS) policies on all database tables
- Input validation and sanitization on all user inputs
- Rate limiting on API endpoints
- CORS configuration for cross-origin requests

### Authentication Security
- JWT tokens with short expiration times
- Refresh token rotation
- Password hashing with bcrypt
- Multi-factor authentication support
- Session management with secure cookies

### Payment Security
- PCI DSS compliant payment processing
- Stripe integration with webhook verification
- No sensitive payment data stored locally
- Fraud detection and prevention measures

### Monitoring & Alerting
- Real-time error tracking with Sentry
- Performance monitoring and alerting
- Security incident response procedures
- Regular security audits and penetration testing

---

## Performance Optimization

### Database Optimization
- Strategic indexing on frequently queried columns
- Query optimization and EXPLAIN plan analysis
- Connection pooling with PgBouncer
- Database query caching with Redis

### Application Optimization
- Code splitting and lazy loading
- Image optimization with Cloudinary
- CDN delivery for static assets
- Service worker for offline functionality

### Caching Strategy
- Redis for session storage and caching
- Browser caching for static assets
- API response caching
- Database query result caching

---

## Testing Strategy

### Unit Tests
```typescript
// __tests__/services/auth.service.test.ts
import { AuthService } from '@/lib/services/auth.service';

describe('AuthService', () => {
  let authService: AuthService;

  beforeEach(() => {
    authService = new AuthService();
  });

  it('should sign up a new user', async () => {
    const result = await authService.signUp('test@example.com', 'password123', 'client');
    expect(result.user).toBeDefined();
  });

  it('should sign in an existing user', async () => {
    const result = await authService.signIn('test@example.com', 'password123');
    expect(result.session).toBeDefined();
  });
});
```

### Integration Tests
```typescript
// __tests__/booking-flow.test.ts
describe('Booking Flow', () => {
  it('should create a booking and process payment', async () => {
    // Create booking
    const booking = await bookingService.createBooking({
      boyfriendId: 'boyfriend-1',
      startTime: new Date(),
      duration: 2,
      serviceType: 'dinner'
    });

    // Process payment
    const payment = await paymentService.confirmPayment(booking.paymentIntentId);

    expect(payment.status).toBe('succeeded');
    expect(booking.status).toBe('confirmed');
  });
});
```

### E2E Tests
```typescript
// e2e/booking.spec.ts
test('complete booking flow', async ({ page }) => {
  await page.goto('/browse');

  // Select boyfriend
  await page.click('[data-testid="boyfriend-card-1"]');

  // Book appointment
  await page.click('[data-testid="book-now"]');
  await page.fill('[data-testid="start-time"]', '2024-01-01T19:00');
  await page.fill('[data-testid="duration"]', '2');
  await page.click('[data-testid="confirm-booking"]');

  // Complete payment
  await page.fill('[data-testid="card-number"]', '4242424242424242');
  await page.click('[data-testid="pay-now"]');

  // Verify booking
  await expect(page.locator('[data-testid="booking-confirmed"]')).toBeVisible();
});
```

---

## API Documentation

### REST API Endpoints

#### Authentication
```
POST /api/auth/signup - User registration
POST /api/auth/signin - User login
POST /api/auth/signout - User logout
POST /api/auth/reset-password - Password reset
```

#### Bookings
```
GET /api/bookings - Get user bookings
POST /api/bookings - Create new booking
PUT /api/bookings/:id - Update booking
DELETE /api/bookings/:id - Cancel booking
```

#### Payments
```
POST /api/payments/create-intent - Create payment intent
POST /api/payments/confirm - Confirm payment
POST /api/payments/refund - Process refund
```

#### Messaging
```
GET /api/messages/conversations - Get user conversations
POST /api/messages - Send message
PUT /api/messages/:id/read - Mark message as read
```

#### Analytics
```
GET /api/analytics/dashboard - Get dashboard metrics
GET /api/analytics/user/:id - Get user analytics
POST /api/analytics/track - Track user event
```

---

## Conclusion

This enterprise-grade platform provides a complete solution for male companion booking services with:

- **Scalable Architecture**: Next.js 15, Supabase, PostgreSQL
- **Secure Payments**: Stripe integration with webhooks
- **Real-time Communication**: WebSocket-based messaging
- **Advanced Analytics**: Comprehensive business intelligence
- **Enterprise Security**: RLS, encryption, monitoring
- **Performance Optimized**: Caching, indexing, CDN
- **Production Ready**: Docker, CI/CD, testing

The platform is designed to handle 1M+ users with enterprise-grade reliability and security.
